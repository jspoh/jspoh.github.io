<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array and methods</title>
    <style>
        code {
            font-weight: 300;
            background-color: gainsboro;
            display: block;
            width: fit-content;
            margin: 5px 0px;
        }

        span.indent {
            color: transparent;
        }
    </style>
</head>

<body>
    <h1>Javascript</h1>
    <hr>
    <h2>Basics</h2>
    <hr>
    <div class="str">
        <p><b>.concat() .includes() .indexOf()</b></p>
        <p><code>let newStr = str1.concat(str2);</code></p>
        <p>
            <code>const colArr = ['red', 'blue'];</code><br>
            To find out if 'blue' is in colArr, use <br>
            <code>colArr.includes('blue');</code> will return boolean value. Only works for arrays.
        </p>
        <p>
            <code>let str = 'hello';</code> <br>
            To find out if 'h' is in str, use .indexOf('h') <br>
            <code>str.indexOf('h');</code> will return -1 if not in str and index if in str
        </p>
    </div>

    <hr>

    <div class="addingremoving">
        <p>
            <b>.push() .pop() .shift() .unshift()</b> <br>
            <code>const arr = [1, 6, 7, 20];</code> <br>
            <br>
            <code>arr.push('x');</code><br>will add x to end of arr - [1,6,7,20,'x'] <br>
            <br>
            <code>let removedItem = arr.pop();</code> <br>will remove last item and store it in variable removedItem
            <br>
            <br>
            <code>arr.shift();</code> <br>removes index 0 item in arr <br>
            <br>
            <code>arr.unshift('x');</code> <br>adds 'x' to index 0 position in arr <br>
            <br>
            <code>arr.reverse();</code> <br>will reverse array and store it back to arr
        </p>
    </div>

    <hr>

    <div class="slicesplice">
        <p>
            <b>.slice() / .splice() / .sort()</b> <br>
            <code>const arr = [1,2,3,4,5];</code> <br>
            <br>
            <code>arr.slice(1);</code> <br>will return [2,3,4,5] <br>
            <br>
            <code>arr.slice(1, 3);</code> <br>will return [2,3] <br>
            <br>
            <code>arr.slice(-2);</code> <br>will return [4,5] <br>
            <br>
            <code>arr.splice(index, no. of items to replace, replace with);</code><br>
            <code>arr.splice(2, 1, 'lol');</code> <br>will return [1,2,'lol',4,5] <br>
        </p>
    </div>
    <p>
        <code>arr.sort()</code> converts everything to string then sorts by utf code. hence if u try to sort <br>
        [1,2,10,9], it will return [1,10,2,9]
    </p>

    <hr>

    <p>
        <b>parseInt()</b> <br>
        <code>userInput = 'a23';</code> <br>
        <br>
        Users may sometimes make typos, but with parseInt, we can get the number in the str or conv str to int.
        <code>parseInt(userInput);</code> <br>will return the value of 23
    </p>

    <hr>

    <div class="forloop">
        <p>
            Normal for loop, should be easy. <br>
            <code>for (let i=0;i&lt;10;i++) {console.log(i);}</code>
        </p>
        <p>
            for ..of loop <br>
            <code>for (let i of array) {console.log(i);}</code> <br>
            basically its the for i in array function in python
        </p>
        <p>
            for ..in loop <br>
            <code>for (let i in array) {console.log(i);}</code> <br>
            If youre using this on an object(class?? dictionary?) i will refer to the keys of the array.
        </p>
        <p>
            <code>Object.values(variable_name);</code> <br>returns the values of the object
        </p>
        <hr>
        <p>
            <br><b> Diving into more advanced for loops now </b><br>
        </p>
        <p>
            <b>.forEach(func) </b><br>
            <code>array.forEach(function(i) {console.log(i);})</code> <br>
            This is p much the same as the for ..of loop
        </p>
        <p>
            <b>.map(func)</b> <br>
            <code>newArr = array.map(function(i) {return i*2;})</code> <br>
            .map creates a new array with the returned values. in this case we created a new array of doubled values.
        <p>
            .map can also be used in objects. here's an example <br>
            <br>
            <code>
            <code>const fullNames = [{first: 'js', last: 'poh'}, {first: 'michael', last: 'jordan'}];</code> <br>
            <code>let firstNames = fullNames.map(function(name) {return name.first;})</code> <br>
            </code> <br>
            Using this, we have created a firstNames array with the map function. I guess for loop works too but this is
            <br>
            more concise?? idk honestly
        </p>
        </p>
    </div>

    <hr>

    <div class="arrow">
        <p>
            Arrow notation for creating functions <br>
            Basically just rewriting a function in a more concise way <br>
            <br>
            Instead of <br>
            <code>function square(x) {return x**2;}</code> <br>
            We can write it like this instead: <br>
            <code>const square = (x) => {return x**2;}</code> <br>
            <br>
            They mean the same thing and you use them the same way. square(9) will return 81.
        </p>
    </div>
    <hr>
    <div class="random">
        <p>
            <b>Random int</b> <br>
            <br>
            To get a random int, we can use this <br>
            <code>Math.ceil(Math.random()*10);</code> <br>
            This will give a rand num from 1-10. <br>
            Math.random will give a random decimal from 0-1. Hence by using Math.ceil, we can convert them into ints and
            * by how many numbers we need.
        </p>
    </div>
    <hr>

    <div class="settimeout">
        <p>
            <b>setTimeout()</b> is basically time.sleep() <br>
            <code>setTimeout(function, time in ms)</code> <br>
            hence if u want the program to wait 5 seconds before printing 'hello', <br>
            <code>setTimeout(()=>{console.log('hello');}, 5000)</code> <br>
            Note that this only works with functions. the ()=>{} is an arrow notation that denotes a function <br>
            If you want to use a prewritten function such as <br>
            <code>
                const sayHi = () => {console.log('hi');}; <br>
                setTimeout(sayHi, 5000);
            </code>
            <br>
            It is written as sayHi and not sayHi() so as to not execute the function right away. <br>
            the count is independent to other stuff altho js is a single threaded language. so if you put 1sec. no
            matter <br>
            what, it will run the code at 1second even if theres another timeout 1sec in front of it. <br>
            The way to get past this is to nest the timeouts in each other or just hardcode the timings
        </p>
        <hr>
        <p>
            <b>setInterval()</b> executes a given function every n milliseconds <br>
            The syntax is the same as setTimeout(). <br>
            <code>setInterval(function, time in ms);</code> <br>
            hence <br>
            <code>setInterval(()=>{console.log(Math.random());}, 1000);</code>
            <br>
            If you want to be able to stop the interval, you need to set the ID. <br>
            <code>const id = setInterval(()=>{console.log(Math.random());}, 1000);</code> <br>
            and to stop it, <br>
            <code>clearInterval(id);</code>
        </p>
    </div>

    <hr>

    <div class="filter">
        <p>
            <b>.filter()</b> <br>
            Allows you to filter returned data from an arr to a new arr. will return the arr value if true. <br>
            <code>const newArr = arr.filter(function)</code> <br>
            <br>
            <code>const arr = [1,2,3,4,5,6,7,8,9];</code>
            <code>const newArr = arr.filter((i)=>{return i&lt;5;});</code> <br>
            will return the value of <br>
            <code>newArr = [1,2,3,4];</code> <br>
            arr will remain unchanged
        </p>
        <p>
            <b>.filter practice</b> <br>
            Write a function called <code>validUserNames</code> that will return a new array of names under 10 chars.
            <br>
            <code>
                function validUserNames(nameArr) { <br>
                <span class="indent">aaaa</span>const newArr = nameArr.filter((name)=>{return name.length &lt; 10;}); <br>
                <span class="indent">aaaa</span>return newArr; <br>
                }
            </code> <br>
            and here's the simplified code. quite confusing zz <br>
            <code>const validUserNames = (nameArr)=>{
                const newArr = nameArr.filter((name)=>{
                    return name.length&lt;10;});
                    return newArr;}</code>
        </p>
    </div>

    <hr>

    <div class="someevery">
        <p>
            <b>.some()</b> <br>
            checks to see if some values in array passes a test and returns a boolean value <br>
            <code>
                examScores.some((score)=>score &gt; 50)
            </code> <br>
            if some scores are above 50, this will return true
        </p>
        <p>
            <b>.every()</b> <br>
            checks to see if every value in array passes the test and returns a boolean value <br>
            <code>
                examScores.every((score)=>score &gt; 50)
            </code>
            every score has to be above 50 for this to return true.
        </p>
        <p>
            Write a function called allEvens to determine if an array consists of even numbers only <br>
            <code>
                const allEvens = (numArr) => {<br>
                <span class="indent">aaaa</span>    const allEven = numArr.every(num=>num%2===0);<br>
                <span class="indent">aaaa</span>    if (allEven) {return true;}br <br>
                <span class="indent">aaaa</span>    else {return false;} <br>
                }
            </code>
        </p>
        <p>
            <b>.reduce()</b> <br>
            Reduces an array to a single value <br>
            <code>
                const arr = [1,2,3,4,5]; <br>
                const sum = arr.reduce((sum, i)=>{return sum+i;});
            </code>
            <br>
            sum will be 1+2+3+4+5; <br>
            If instead of finding the sum of all numbers in arr i wna find the biggest number, <br>
            <code>
                const arr = [1,3,2,4,6,5]; <br>
                const biggestNum = arr.reduce((max, i)=>{if (i&gt;max){return i;} return max;});
            </code> <br>
            biggestNum will be 6 in this case.
        </p>
    </div>

    <hr>

    <div class="default">
        <b>default parameters</b> <br>
        self-explanatory stuff <br>
        <code>
            const add = (a=0,b=0) => {return a+b;};
        </code>
        <br>
        value defaults to 0 if no args provided. so it will return 0 instead of NaN if <br>
        <code>add();</code>
    </div>

    <hr>

    <div class="spread">
        <p>
            <b>Spread in function calls</b> <br>
            pass in 1 array as an argument to a function that expects multiple <br>
            <code>
                const arr = [1,2,3]; <br>
                Math.max(...arr);
            </code><br>
            yes, its the 3 dots lol. kinda like removing the array brackets [] <br>
            can be useful in combining arrays, like so: <br>
            <code>
                const landAnimals = ['dog', 'cat']; <br>
                const flightedAnimals = ['bat', 'bird']; <br>
                const allAnimals = [...landAnimals, ...flightedAnimals];
            </code>
        </p>
    </div>

    <hr>

    <div class="args">
        <p>
            <b>Passing in multiple args to a function</b> aka rest params <br>
            <code>
                const func = (...args) => {console.log(args);};
            </code> <br>
            All arguments passed in will be stored in an array format tied to variable args <br>
            with this, we can write better add statements that take multiple values like this <br>
            <code>
                function add(...numArr) {<br>
                <span class="indent">aaaa</span>    return numArr.reduce((sum, i)=>sum+i); <br>
                }
            </code> <br>
            <code>
                const add = (...numArr) => {return numArr.reduce((sum, i)=>sum+i);}
            </code> <br>
            i guess writing the return in front of arr.reduce() will return the sum value <br>
            Another example:
            <code>
                const winners = (champ, ...participantArr)=>{console.log(`Champion: ${champ}\nThanks to everyone else:\n${participantArr}`);};
            </code> <br>
            The above code will output:
            <code>
                Champion: name <br>
                Thanks to everyone else: <br>
                name, name, name, etc
            </code>
        </p>
    </div>

    <hr>

    <div class="arrdestructure">
        <p>
            <b>Array destructuring</b> <br>
            <code>
                const numArr = [1,2,3,4,5]; <br>
                const [x,y,z,...theRest] = numArr;
            </code> <br>
            x will be 1, y will be 2, z will be 3, and theRest will be an array containing the remaining values[4,5] in
            this case <br>
        </p>
        <p>
            <b>Object destructuring</b> <br>
            <code>
                const user = {name: 'john', age: '29', gender: 'male'}; <br>
                const name = user.name;
            </code> <br>
            I could do this to put the user.name in a new variable but can prove tedious if i need to do it for many
            items so <br>
            <code>
                const user = {name: 'john', age: '29', gender: 'male'}; <br>
                const {name, age, gender:sex} = user;
            </code>
            In the above case, i saved the gender value into a variable called sex instead <br>
            default values can also be used here in case some user values may be blank <br>
            <code>
                const user = {name: 'john', age: '29', gender: 'male'}; <br>
                const {name, age='unknown', gender:sex} = user;
            </code>
        </p>
        <p>
            <b>Parameter destructuring</b> <br>
            <code>
                const user = {name: 'john', age: '29', gender: 'male'}; <br>
                const intro = (u)=>{console.log(`He is ${u.name}, aged ${u.age}.`);};
            </code>
            with parameter destructuring, we can instead write the code like this <br>
            <code>
                const user = {name: 'john', age: '29', gender: 'male'}; <br>
                const intro = (u)=>{const {name:n, age:a}=u; console.log(`He is ${n}, aged ${a}.`);};
            </code>
            if we destructure it even more, <br>
            <code>
                const user = {name: 'john', age: '29', gender: 'male'}; <br>
                const intro = ({name:n, age:a})=>{console.log(`He is ${n}, aged ${a}.`);};
            </code>
            just to explain a little more, this separates the name and age values from the entire object right away
        </p>
    </div>

    <hr>

    <h2>Document Object Model (DOM)</h2>
    <hr>

    <div class="targeting">
        <p>
        <ul> <b>
                <li>Ways to target certain elements</li>
                <ul>
                    <li>getElementById</li>
                    <li>getElementsByTagName</li>
                    <li>getElementsByClassName</li>
                </ul>
        </ul> </b>
        Can use console to show the object with ID: <br>
        <code>
            const variable = document.getElementById('ID');
            console.dir(variable);
        </code>
        as for tag name, index may be passed in to refer to a specific object:<br>
        <code>
            const allImages = document.getElementsByTagName('img');
            console.dir(allImages[index]);
        </code>
        note that this creates a HTMLCollection, not an array. <br>
        classes are p much the same as ID: <br>
        <code>
            const variable = document.getElementsByClassName('class');
            console.dir(variable);
        </code> <br>
        Always use ID if only selecting a single element.
        </p>
    </div>

    <div class="queryselector">
        <p>
            <b>querySelector, querySelectorAll</b> <br>
            Better way to select stuff, just look: <br>
            <code>
                document.querySelector('img'); <br>
                document.querySelector('#id'); <br>
                document.querySelector('.class'); <br>
            </code>
            However, query selector only shows the first match instead of all items as compared to the previous method
            that returns a HTMLCollection. <br>
            IDs remained unchanged of course since you should only be selecting one in the first place. <br>
            If you would like to select something other than the first img for example, <br>
            <code>
                document.querySelector('img:nth-of-type(2)');
            </code>
            This will select the 2nd img element. <br>
            If you really want a HtmlCollection using querySelector, use querySelectorAll instead. <br>
            <code>
                document.querySelectorAll('img');
            </code>
            You can use similar stuff like css. for example, <br>
            <code>
                document.querySelector('p a');
                document.querySelector('a.big');
            </code>
        </p>
    </div>

    <div class="inner">
        <p>
            <b>.textContent vs .innerText</b> <br>
            .textContent shows what is written in the HTML doc but .innerText only shows whats displayed. <br>
            Hence, if display:none, it will still show up on .textContent but not .innerText <br>
            <br>
            <b>.innerHTML</b> <br>
            however, with .innerHTML, it will retrieve everything inside, including stuff like p tags, div tags, spans,
            bold
            etc. so if you wna add a span in a p or make some words bold for example, you should use .innerHTML
            <br>
            to update value, can use = to change completely or or += to append
        </p>
    </div>

    <div class="input">
        <p>
            <b>querySelector('input[type='text']')</b>
        </p>
    </div>

    <div class="attribute">
        <p>
            <b>.setAttribute</b> <br>
            can be used to change certain elements, classes, ids etc <br>
            <code>
                document.querySelector('img').setAttribute('src', 'https://devsprouthosting.com/images/chicken.jpg');
            </code> <br>
            this means ive changed the src to this new img link
        </p>
    </div>

    <div class="styles">
        <p>
            <b>changing styles with javascript</b> <br>
            <code>
                const h1 = document.querySelector('h1'); <br>
                h1.style.fontSize = '100px';
            </code>
            in css we use font-size but in js its in camelCase hence fontSize. <br>
            dont be alarmed if it doenst contain info from the .css stylesheet. it only reads from html.
        </p>
    </div>

    <div class="iteratejs">
        <p>
            <b>for loops to change stuff</b> <br>
            <code>
                html code: <br>
                h1  <br>
                span R <br>
                span A <br>
                span I <br>
                span N <br>
                span B <br>
                span O <br>
                span W <br>
                <br>
                js code: <br>
                const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']; <br>
                <br>
                const allSpans = document.querySelectorAll('h1 span'); <br>
                <br>
                let i = 0;<br>
                for (let span of allSpans) { <br>
                <span class="indent">aaaa</span>    span.style.color = colors[i]; <br>
                <span class="indent">aaaa</span>    i++; <br>
                } <br>
            </code>
        </p>
    </div>

    <div class="classlist">
        <p>
            <b>.classList</b> <br>
            this can be used to add or remove classes from elements <br>
            <code>
                const h1 = document.querySelector('h1'); <br>
                h1.classList.add('className'); <br>
                h1.classList.remove('className'); <br>
                h1.classList.toggle('className')
            </code>
            add and remove shld be self explanatory, but toggle basically is like a switch to toggle it on or off. <br>
            so if the class is already present, it will remove it and vice versa.
        </p>
    </div>

    <div class="parentchildelement">
        <p>
            <b>.parentElement</b> <br>
            references the parent element. so for example if i have a div p b tag, <br>
            <code>
                const firstBold = document.querySelector('b'); <br>
                firstBold.parentElement; <br>
                firstBold.parentElement.parentElement;
            </code>
            this would refer to p and div respectively
        </p>
        <p>
            <b>.childElement</b> <br>
            the opposite would be true here <br>
            <code>.childElementCount</code>
            will show the number of child elements whereas <br>
            <code>.children</code>
            will show the respective children tags/elements
        </p>
    </div>

    <div>
        <p>
            <b>Creating a new img element and appending it to body</b> <br>
            <code>
                const newImg = document.createElement('img'); <br>
                newImg.src = 'link'; <br>
                document.body.append('newImg'); <br>
                newImg.classList.add('className');
            </code>
            created a new img with src and added to the end of body element. adding class is for css styles
        </p>
        <p>
            <b>Creating paragraph element with a bg color of blue and appending it to body</b> <br>
            <code>
                const newP = document.createElement('p'); <br>
                newP.innerText = 'I am a new paragraph!'; <br>
                newP.style.backgroundColor = 'blue'; <br>
                document.body.append(newP);
            </code>
        </p>

        <p>
            <b>.prepend</b> <br>
            basically adds to the element but at the front, kind of like append but yea, at the front.
        </p>

        <p>
            <b>.append/.appendChild practice</b> <br>
            <code>
                for (let i=0; i&lt;100; i++) { <br>
                    const newButton = document.createElement('button'); <br>
                    newButton.innerText = 'Hey!'; <br>
                    const container = document.querySelector('#appContainer'); <br>
                    container.appendChild(newButton); <br>
                }
            </code>
            if you run the above code, you will get 100 buttons below this line
        <p id="appContainer"></p>
        </p>

        <p>
            <b>.remove()</b> <br>
            This text will be removed if you run the code below -&gt; <span id="remove">I will be removed!</span> <br>
            <code>
                document.querySelector('#remove').remove();
            </code>
        </p>
    </div>

    <hr>
    <h2>DOM Events</h2>
    <p><b>Event reactions etc.</b></p>
    <hr>

    <div class="onclick">
        <p>
            <b>onclick event</b> <br>
            this can be done in the html document itself, although unrecommended <br>
            <button onclick="alert('you clicked me!'); alert('stop clicking!');">click me!</button> <br>
            code: <br>
            <code>
                &lt;button onclick="alert('you clicked me!'); alert('stop clicking!');"&gt;click me!&lt;/button&gt;
            </code>
            you can also do a doubleclick thing <br>
            <button ondblclick="alert('double-clicked!')">double click me!</button> <br>
            code: <br>
            <code>
                &lt;button ondblclick="alert('double-clicked!')"&gt;click me!&lt;/button&gt;
            </code>
        </p>
        <p>The above way is not a good way to do it, should use the js file instead</p>
        <p>
            <b>better onclick</b> <br>
            <code>
                const btn = document.querySelector('#v2'); <br>
                btn.onclick = ()=>{alert('you clicked me v2!');}
            </code>
            <button id="v2">click me after pasting the above code into the console!</button>
        </p>
    </div>

    <div class="onmouseenter">
        <p>
            <b>onmouseenter event</b> <br>
            <code>
                const notouch = ()=&gt;{console.log('AAAAAHHH!'); console.log('DONT TOUCH MEE!');} <br>

                const btn = document.querySelector('#ome'); <br>
                btn.onmouseenter = notouch;
            </code>
            <button id="ome">DONT TOUCH ME!</button> <br>
            take note that btn.onmouseenter=notouch; and not notouch(); <br>
            this is to only execute the function when btn.onmouseenter <br>
            if written as notouch(), the function will execute straight away.
        </p>
    </div>

    <div class="eventlistener">
        <p>
            <b>addEventListener (best way)</b> <br>
            <code>
                const btn = document.querySelector('#ael'); <br>
                btn.addEventListener('click', function(){alert('clicked!')})
            </code>
            <button id="ael">click me!</button>
        </p>
        <p>
            addEventListener is best because we can <b>call multiple functions</b> <br>
            <code>
                const btn = querySelector('#id'); <br>
                btn.onclick = function1; <br>
                btn.onclick = function2; <br>
            </code>
            The above code will only output function 2 when button is clicked as it is overwritten <br>
            however, with event listener, we can call multiple functions thats why it is better <br>
            here's how it should be written: <br>
            <code>
                const btn = querySelector('#id'); <br>
                btn.addEventListener('click', function1); <br>
                btn.addEventListener('click', function2); <br>
            </code>
            now it will run function 1 and then 2 respectively. <br>
            <br>
            <b>call function1 once along with function2 and then call function2 only subsequently</b> <br>
            <code>
                const btn = querySelector('#id'); <br>
                btn.addEventListener('click', function1, {once: true}); <br>
                btn.addEventListener('click', function2); <br>
            </code>
        </p>
    </div>
    <hr>
    <div class="key">
        <p>
            <b>keylogging</b> <br>
            <code>
                const input = document.querySelector('input'); <br>
                input.addEventListener('keydown', function(e){console.log(e);});
            </code>
            This code will show everything whereas <br>
            <code>
                const input = document.querySelector('input'); <br>
                input.addEventListener('keydown', function(e){console.log(e.key);console.log(e.code);});
            </code>
            If you're making a game or just want to log ALL KEYS, <br>
            <code>
                window.addEventListener('keydown', function(e){console.log(e.key, e.code);});
            </code>
            with that, we can create a switch case to log arrow/keyboard key controls <br>
            <code>
                window.addEventListener('keydown', function(e){ <br>
                &emsp;switch(e.code.toLowerCase()) { <br>
                &emsp;&emsp;case 'arrowup': <br>
                &emsp;&emsp;case 'keyw': <br>
                &emsp;&emsp;&emsp;console.log('up'); <br>
                &emsp;&emsp;&emsp;break; <br>
                &emsp;&emsp;case 'arrowdown': <br>
                &emsp;&emsp;case 'keys': <br>
                &emsp;&emsp;&emsp;console.log('down'); <br>
                &emsp;&emsp;&emsp;break; <br>
                &emsp;&emsp;case 'arrowleft': <br>
                &emsp;&emsp; case 'keya': <br>
                &emsp;&emsp;&emsp;console.log('left'); <br>
                &emsp;&emsp;&emsp;break; <br>
                &emsp;&emsp;case 'arrowright': <br>
                &emsp;&emsp;case 'keyd': <br>
                &emsp;&emsp;&emsp;console.log('right'); <br>
                &emsp;&emsp;&emsp;break; <br>
                &emsp;&emsp;default: <br>
                &emsp;&emsp;&emsp;console.log('invalid!'); <br>
                &emsp;} <br>
                });
            </code>
        </p>
    </div>
    <hr>
    <h2>Form events, preventDefault</h2>
    <hr>

    <div class="preventdefault">
        <b>preventDefault()</b> <br>
        Usually when we submit a form, it would bring us to a different page. Sometimes, we don't want that. <br>
        <code>
            const form = document.querySelector('#formId'); <br>
            form.addEventListener('submit', function(e){ <br>
            &emsp;e.preventDefault(); <br>
            &emsp;console.log('form submitted'); <br> 
            })
        </code>
        This code will keep us on the same page after submission.
    </div>

    <div class="formpractice">
        <p><b>Let's create a form to practice</b></p>
        <form id="formprac" action="">
            <h3>List</h3>
            <p>
                <label for="addtolist">Add to list:</label>
                <input type="text" id="addtolist" placeholder="Item to add to list" required>
                <button id="submitbtn">Submit</button>
            </p>
            Stuff in list:
            <ul id="formlist">
            </ul>
        </form>
        <br>
        <p>This code gives the form above it's function</p>
        <code>
            const form = document.querySelector('#formprac'); <br>
            const inputField = document.querySelector('#addtolist') <br>
            <br>
            form.addEventListener('submit', (e)=>{ <br>
                &emsp;e.preventDefault(); <br>
                &emsp;const newLi = document.createElement('li'); <br>
                &emsp;newLi.innerText = inputField.value; <br>
                &emsp;document.querySelector('#formlist').append(newLi); <br>
                &emsp;inputField.value = ''; <br>
            });     
        </code>
    </div>

    <div class="change">
        <p>
            <b>change event</b> <br>
            <code>
                const input = document.querySelector('#input'); <br>
                input.addEventListener('change', function(e){console.log('change');});
            </code>
            This code will log whenever input field is changed. you have to select something else for it to read. <br>
            <input type="text" id="input">
        </p>
    </div>

    <div class="input">
        <p>
            <b>input event</b> <br>
            <code>
                const input = document.querySelector('#inputeg'); <br>
                input.addEventListener('input', function(e){console.log(e.data);});
            </code>
            This code will log whenever you input stuff. this will log the current key input. <br>
            <input type="text" id="inputeg">
        </p>
        <p>
            We can also make another paragraph or any other element follow the content in the input field. <br>
            <code>
                const input = document.querySelector('#inputCopy'); <br>
                input.addEventListener('input', function(e){ <br>
                &emsp;if (input.value) { <br>
                &emsp;&emsp;document.querySelector('#copiedText').innerText = e.data.toUpperCase(); <br>
                &emsp;&emsp;document.querySelector('#currentinput').innerText = input.value; <br>
                &emsp;} <br>
                &emsp;else { <br>
                &emsp;document.querySelector('#currentinput').innerText = 'None'; <br>
                &emsp;} <br>
                }); 
            </code>
            <input type="text" id="inputCopy"> <br>
            Current input letter: <span id="copiedText">None</span> <br>
            Current input: <span id="currentinput">None</span>
        </p>
    </div>

    <div class="bubbling">
        <b>Event bubbling</b> <br>
        If you have a span in p in div and all of them have onclick reactions, they will all play. <br>
        to stop it, you have to add <b>event.stopPropagation()</b> in the eventlistener function.
    </div>

    <div class="delegation">
        <b>Event delegation</b> <br>
        I have 2 li tags and ive written a for loop to iterate over them to add event listeners so that if i click <br>
        on them, display will be set to none. However, this will not work for new li elements that I add via input
        forms. <br>
        hence, i need to shift focus to the <b>target</b> inside the parent element <b>ul</b> <br>
        here's an example: <br>
        <form id="formdel" action="">
            <input type="text" id="inputdel"> <button>Submit</button>
        </form>
        List: <br>
        <ul id="uldel">
            <li>Click me to make me disappear!</li>
        </ul>
        code: <br>
        <code>
        const delinput = document.querySelector('#inputdel'); <br>
        const delform = document.querySelector('#formdel'); <br>
        const delul = document.querySelector('#uldel'); <br>
        <br>
        delform.addEventListener('submit', (e) => { <br>
        &emsp;    e.preventDefault(); <br>
        &emsp;    const newLi = document.createElement('li'); <br>
        &emsp;    newLi.innerText = delinput.value; <br>
        &emsp;    delul.append(newLi); <br>
        &emsp;    delinput.value = ''; <br>
        }); <br>
        <br>
        delul.addEventListener('click', (e) => { <br>
            &emsp;    e.target.nodeName === 'LI' && e.target.remove(); <br>
        });
        </code> <br>
        <code>
            e.target.nodeName === 'LI' && e.target.remove(); 
        </code>
        is basically the same as <br>
        <code>
            if (e.target.nodeName === 'LI') {e.target.remove();}
        </code> <br>
        This is to ensure that you're only removing li elements on click. <br>
        note that li has to be in <b>caps</b>.
    </div>

    <hr>
    <h2>Animations (CSS AND JS)</h2>
    <hr>
    <div class="animations">
        <p>
            <b>We're mainly going to talk about those animations that make elements appear when we scroll on the
                page</b><br> They will fade in and transform up, left, or right into view. <br> <br>

            <b>[CSS]</b> <br>
            First, we need to create a few classes: <b>.animated, .active, .revealUp, .revealLeft, .revealRight</b> <br>
            <br>
            <b>.animated</b> - no need to change anything, we just use this to determine what needs to be animated <br>
            <b>.active</b> - this class will be added to anything that is currently in animation <br>
            <code>
                .active {transform: translateY(0px); opacity: 1;}
            </code>
            <b>.revealUp</b> - will set the initial position at a lower pos so that it can fade upwards <br>
            <code>
                .revealUp {position: relative; transform: translateY(50px); opacity: 0; transition: 1s all ease;}
            </code>
            <b>.revealLeft</b> - same thing as .revealUp, but this time set initial pos to left <br>
            <code>
                .revealLeft {position: relative; transform: translateX(-50px); opacity: 0; transition: 1s all ease;}
            </code>
            <b>.revealRight</b> - see .revealLeft <br>
            <code>
                .revealRight {position: relative; transform: translateX(50px); opacity: 0; transition: 1s all ease;}
            </code>
            <br> <br>
            <b>[JS]</b> <br>
            <code>
                function animated(){ <br>
                &emsp;const animated = document.querySelectorAll('.animated'); <br>
                &emsp;const windowHeight = window.innerHeight; <br>
                &emsp;for (let i of animated) { <br>
                    &emsp;&emsp;//find distance between element top border and top of screen <br>
                    &emsp;&emsp;let elementTop = i.getBoundingClientRect().top; <br>
                    &emsp;&emsp;//set how much distance elementTop and screen bottom before starting animation <br>
                    &emsp;&emsp;let elementVisible = 100; <br>
                    <br>
                    &emsp;&emsp;//if element top position is higher than preset distance from screen bottom(elementVisible) <br>
                    &emsp;&emsp;if (elementTop &lt; windowHeight - elementVisible) { <br>
                        &emsp;&emsp;&emsp;i.classList.add('active'); <br>
                        &emsp;&emsp;} <br>
                        &emsp;&emsp;else {i.classList.remove('active');} <br>
                        &emsp;} <br>
                }
            </code>
            paste the code in the console if you have trouble reading. all explanations are inside ^
        </p>
    </div>

    <hr>
    <h2>Creating tabs</h2>
    <hr>
    <div class="tabs">
        <p>
            <b>Sometimes we want to display multiple images/info text via tabs to save the user from scrolling too
                much</b> <br>
            This requires application in HTML CSS and JS. <br>
            <br>
            <b>[JS]</b> <br>
            <code>
                function openTab(tabName) { <br>
                    &emsp;    const tabContent = document.querySelectorAll('.tabcontent'); <br>
                    &emsp;    for (let i=0; i&lt;tabContent.length;i++) {  <br>
                        &emsp;&emsp;        tabContent[i].style.display = 'none'; //this hides all the tab elements <br>
                        &emsp;    } <br>
                        &emsp;    document.querySelector(`#${tabName}`).style.display = 'block'; //shows selected element <br>
                <br>
                        &emsp;    const tablink = document.querySelectorAll('.tablink'); <br>
                        &emsp;    for (let i=0; i&lt;tablink.length;i++) { <br>
                            &emsp;&emsp;        tablink[i].classList.remove('selected'); //removing selected class from all tablinks <br>
                            &emsp;    } <br>
                            &emsp;    document.querySelector(`.${tabName}`).classList.add('selected'); // adding selected class to the selected tablink <br>
                }
            </code>
            As for <b>HTML</b>, <br>
            <code>class="tablink tabName" onclick="openTab('tabName')'</code>
            will be required on each of the tab buttons <br>
            <code>id="tabName" class="tabcontent"</code>
            will be given to each div wrapping the contents of each tab <br>
            The adding and removing of selected classes is to highlight the selected tab in a different color <br>
            <br>
            <b>CSS</b>
            <code>
                .tab{
                    overflow: hidden;
                    border: 1px solid #ccc;
                    background-color: #001d3d;
                    width: 80%;
                    margin: auto;
                    display: flex;
                    justify-content: space-evenly;
                } <br>
                .tab button{
                    background-color: #001d3d;
                    border: none;
                    outline: none;
                    cursor: pointer;
                    padding: 1em 15%;
                    transition: 1s;
                    font-size: 1.3em;
                    color: white;
                } <br>
                .tab button:hover {
                    background-color: #457b9d;
                } <br>
                .tabcontent {
                    display: none;
                    padding: 6px 12px;
                    border: 0px solid #ccc;
                    border-top: none;
                    width: 80%;
                    margin: auto;
                    background-color: #001d3d;
                } <br>
                .container {
                    display: flex;
                    padding: 10px 25px;
                    margin-bottom: 40px;
                    align-items: center;
                } <br>
                .inline {
                    display: inline-block;
                } <br>
                .tablink.selected {
                    background-color: #457b9d;
                }
            </code>
        </p>
    </div>
    <hr>
    <div class="backup">
        <p>
            <b>Requests with callbacks</b> <br>
            <code>
                makeRequest(()=>{//do this},()=>{//if prev function didnt work, do this});
            </code>
            fk la idk wtf this is
        </p>
    </div>
    <hr>
    <h2>Promises</h2>
    <hr>
    <div class="promise">
        <p>
            <code>
                new Promise((resolve, reject)=>{//can either resolve(), reject(), or ignore})
            </code>
            if resolve() or reject() isnt passed in, the status would be pending. <br>
            to add on to the thing above <br>
            <code>
                const request = (url) => { <br>
                    &emsp;return new Promise((resolve, reject)=>{ <br>
                        &emsp;&emsp;const rand = Math.random(); <br>
                        &emsp;&emsp;setTimeout(()=>{ <br>
                            &emsp;&emsp;&emsp;if (rand&gt;0.5) {resolve('data');} <br>
                            &emsp;&emsp;&emsp;else {reject('Server timeout');} <br>
                            &emsp;&emsp;}) <br>
                            &emsp;}) <br>
                } <br>
                <br>
                request('/search/goodstuff') <br>
                &emsp;.then((data)=>{ <br>
                    &emsp;&emsp;console.log('Data:', data); <br>
                }) <br>
                &emsp;.catch((err)=>{ <br>
                    &emsp;&emsp;console.log('Error:', err); <br>
                })
            </code>
            .then will run if promise is resolved, .catch will run if promise is rejected <br>
            seems like a load of stuff idek what it is for, but heres a practical application <br>
            <code>
                const delayedColorChange = (color, delay)=>{ <br>
                    &emsp;return new Promise((resolve, reject)=>{ <br>
                        &emsp;&emsp;setTimeout(()=>{ <br>
                            &emsp;&emsp;&emsp;document.querySelector('body').style.backgroundColor = color; <br>
                            &emsp;&emsp;&emsp;resolve(); <br>
                            &emsp;&emsp;}, delay); <br>
                            &emsp;}) <br>
                } <br>
                <br>
                delayedColorChange('red', 1000) <br>
                &emsp;.then(()=>delayedColorChange('green', 1000)) <br>
                &emsp;.then(()=>delayedColorChange('blue', 1000)) <br>
                &emsp;.then(()=>delayedColorChange('black', 1000)) <br>
                &emsp;.then(()=>delayedColorChange('white', 1000)) <br>
                <br>
                document.querySelector('body').style.transition = '1s all ease';
            </code>
            The above code will change colors smoothly <br>
            <b>i guess if youre calling a function, dont put {}</b>
        </p>
    </div>
    <hr>
    <h2>Asynchronous functions</h2>
    <hr>
    <div class="async">
        <b>async funtions</b> <br>
        async functions automatically return a promise <br>
        <code>
            async function asyncFunc(){ <br>
                &emsp;const rand = Math.random(); <br>
                &emsp;if (rand&gt;0.5) {return 'returning stuff = resolved'} <br>
                &emsp;else {throw new Error('Error = rejected')} <br>
            } <br>
            <br>
            const newFunc = async (){ <br>
                &emsp;same stuff as above <br>
            } <br>
        </code>
        as stated above, return stuff to resolve promise, throw an error to reject it <br>
        wit this, we can use .then and .catch: <br>
        <code>
            async function asyncFunc(){ <br>
                &emsp;const rand = Math.random(); <br>
                &emsp;if (rand&gt;0.5) {return 'returning stuff = resolved'} <br>
                &emsp;else {throw new Error('Error = rejected')} <br>
            } <br>
            <br>
            asyncFunc() <br>
            &emsp;.then(data => {console.log('Promise resolved:', data);}) <br>
            &emsp;.catch(err => {console.log('Promise rejected:', err);})
        </code>
        <br>
        Small real world example: technically else if and else arent needed here.. but wtv<br>
        <code>
            const login = async (user, pw) => { <br>
                &emsp;if (!user || !pw) {throw 'Missing credentials'} <br>
                &emsp;else if (user === 'username' && pw === 'password') {return 'Welcome!'}  <br>
                &emsp;else {throw 'Invalid password!'} <br>
            } <br>
            <br>
            login('username', 'password') <br>
                &emsp;.then(msg=>{console.log('Successfully logged in!'); console.log(msg);}) <br>
                &emsp;.catch(msg=>{console.log(msg)}) <br>
        </code>
    </div>
    <div class="await">
        <p>
            <b>Await</b> <br>
            await will pause execution of a function while waiting for a promise to be resolved <br>
            await can only be used in conjunction with async functions. lets go back to our color changer thing. <br>
            <code>
                const delayedColorChange = (color, delay)=>{ <br>
                    &emsp;return new Promise((resolve, reject)=>{ <br>
                        &emsp;&emsp;setTimeout(()=>{ <br>
                            &emsp;&emsp;&emsp;document.querySelector('body').style.backgroundColor = color; <br>
                            &emsp;&emsp;&emsp;resolve(); <br>
                            &emsp;&emsp;}, delay); <br>
                            &emsp;}) <br>
                } <br>
                <br>
                async function colorChange() { <br>
                &emsp;await delayedColorChange('red', 1000); <br>
                &emsp;await delayedColorChange('green', 1000); <br>
                &emsp;await delayedColorChange('blue', 1000); <br>
                &emsp;await delayedColorChange('black', 1000); <br>
                &emsp;await delayedColorChange('white', 1000); <br>
                }<br>
                document.querySelector('body').style.transition = '1s all ease'; <br>
                colorChange();
            </code>
            instead of using so many .then, we can just use await and call the function <br>
            so much better tbh lol
        </p>
    </div>

    <script>
        // for stuff in list
        const listform = document.querySelector('#formprac');
        const inputField = document.querySelector('#addtolist')

        listform.addEventListener('submit', (e) => {
            e.preventDefault();
            const newLi = document.createElement('li');
            newLi.innerText = inputField.value;
            document.querySelector('#formlist').append(newLi);
            inputField.value = '';
        });

        //for input event
        const ininput = document.querySelector('#inputCopy');
        ininput.addEventListener('input', function (e) {
            if (input.value) {
                document.querySelector('#copiedText').innerText = e.data.toUpperCase();
                document.querySelector('#currentinput').innerText = ininput.value;
            }
            else {
                document.querySelector('#currentinput').innerText = 'None';
            }
        });

        //for event delegation
        const delinput = document.querySelector('#inputdel');
        const delform = document.querySelector('#formdel');
        const delul = document.querySelector('#uldel');

        delform.addEventListener('submit', (e) => {
            e.preventDefault();
            const newLi = document.createElement('li');
            newLi.innerText = delinput.value;
            delul.append(newLi);
            delinput.value = '';
        });

        delul.addEventListener('click', (e) => {
            e.target.nodeName === 'LI' && e.target.remove();
        });
    </script>
</body>

</html>